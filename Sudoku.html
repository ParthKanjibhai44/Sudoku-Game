<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
        }
        /* Style for the Sudoku grid cells */
        .sudoku-cell {
            width: clamp(30px, 10vw, 50px);
            height: clamp(30px, 10vw, 50px);
            text-align: center;
            font-size: clamp(16px, 5vw, 24px);
            border: 1px solid #d1d5db; /* gray-300 */
            caret-color: #3b82f6; /* blue-500 */
            transition: all 0.2s ease-in-out;
        }
        /* Thicker borders for the 3x3 subgrids */
        .sudoku-cell:nth-child(3n) {
            border-right-width: 3px;
            border-right-color: #374151; /* gray-700 */
        }
        .sudoku-cell:nth-child(9n) {
            border-right-width: 1px;
            border-right-color: #d1d5db;
        }
        #sudoku-grid .row:nth-child(3n) .sudoku-cell {
            border-bottom-width: 3px;
            border-bottom-color: #374151; /* gray-700 */
        }
        #sudoku-grid .row:last-child .sudoku-cell {
            border-bottom-width: 1px;
            border-bottom-color: #d1d5db;
        }
        #sudoku-grid .row .sudoku-cell:first-child {
             border-left-width: 3px;
             border-left-color: #374151;
        }
         #sudoku-grid .row .sudoku-cell:last-child {
             border-right-width: 3px;
             border-right-color: #374151;
        }
        #sudoku-grid .row:first-child .sudoku-cell {
            border-top-width: 3px;
            border-top-color: #374151;
        }
        #sudoku-grid .row:nth-child(9) .sudoku-cell {
            border-bottom-width: 3px;
            border-bottom-color: #374151;
        }
        /* Styling for pre-filled cells */
        .pre-filled {
            background-color: #f3f4f6; /* gray-100 */
            color: #1f2937; /* gray-800 */
            font-weight: 600;
        }
        /* Highlight for selected cell and its row/column/box */
        .highlight {
            background-color: #dbeafe; /* blue-100 */
        }
        .selected {
            background-color: #93c5fd !important; /* blue-300 */
            box-shadow: 0 0 0 2px #3b82f6; /* blue-500 */
            z-index: 10;
        }
        /* Style for incorrect user-entered numbers */
        .incorrect {
            background-color: #fecaca; /* red-200 */
            color: #b91c1c; /* red-700 */
        }
        /* Styles for the message box */
        #message-box {
            transition: opacity 0.5s, transform 0.5s;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-4xl font-bold text-gray-700">Sudoku</h1>
            <div id="attempts-container" class="text-xl font-semibold text-gray-600">
                <!-- Attempts will be rendered here by JS -->
            </div>
        </div>

        <!-- Sudoku Grid -->
        <div id="sudoku-grid" class="grid grid-cols-1 gap-0 bg-white rounded-lg shadow-lg overflow-hidden mx-auto w-max">
            <!-- Rows and cells will be generated by JavaScript -->
        </div>

        <!-- Controls -->
        <div class="flex justify-center space-x-2 sm:space-x-4 mt-6">
            <button id="new-game-btn" class="px-4 py-2 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 transition-transform transform hover:scale-105">New Game</button>
            <button id="check-btn" class="px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75 transition-transform transform hover:scale-105">Check</button>
            <button id="solve-btn" class="px-4 py-2 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-75 transition-transform transform hover:scale-105">Solve</button>
        </div>
        
        <!-- Message Box -->
        <div id="message-box" class="mt-4 text-center text-lg font-medium p-3 rounded-lg opacity-0 transform scale-95"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Constants and Global Variables ---
            const GRID_SIZE = 9;
            const BOX_SIZE = 3;
            const EMPTY_CELL = 0;
            const MAX_ATTEMPTS = 3;

            const gridElement = document.getElementById('sudoku-grid');
            const newGameBtn = document.getElementById('new-game-btn');
            const checkBtn = document.getElementById('check-btn');
            const solveBtn = document.getElementById('solve-btn');
            const messageBox = document.getElementById('message-box');
            const attemptsContainer = document.getElementById('attempts-container');

            let board = [];
            let solution = [];
            let failureAttempts = MAX_ATTEMPTS;
            let isGameOver = false;

            // --- Board Generation ---

            function generatePuzzle() {
                board = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(EMPTY_CELL));
                solution = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(EMPTY_CELL));
                
                solveSudoku(board); // Generate a full solution
                
                // Copy the full solution before poking holes
                for (let i = 0; i < GRID_SIZE; i++) {
                    solution[i] = [...board[i]];
                }

                pokeHoles(45); // Adjust number for difficulty (e.g., 40-55)
            }

            function solveSudoku(grid) {
                const findEmpty = () => {
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            if (grid[r][c] === EMPTY_CELL) return [r, c];
                        }
                    }
                    return null;
                };

                const emptySpot = findEmpty();
                if (!emptySpot) return true; // Solved
                const [row, col] = emptySpot;

                const nums = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);

                for (let num of nums) {
                    if (isValid(grid, row, col, num)) {
                        grid[row][col] = num;
                        if (solveSudoku(grid)) return true;
                        grid[row][col] = EMPTY_CELL; // Backtrack
                    }
                }
                return false;
            }

            function isValid(grid, row, col, num) {
                // Check row, column, and 3x3 box
                for (let i = 0; i < GRID_SIZE; i++) {
                    if (grid[row][i] === num && i !== col) return false;
                    if (grid[i][col] === num && i !== row) return false;
                }
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let r = 0; r < BOX_SIZE; r++) {
                    for (let c = 0; c < BOX_SIZE; c++) {
                        if (grid[startRow + r][startCol + c] === num && (startRow + r !== row || startCol + c !== col)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            function pokeHoles(holes) {
                let removed = 0;
                while (removed < holes) {
                    const row = Math.floor(Math.random() * GRID_SIZE);
                    const col = Math.floor(Math.random() * GRID_SIZE);
                    if (board[row][col] !== EMPTY_CELL) {
                        board[row][col] = EMPTY_CELL;
                        removed++;
                    }
                }
            }
            
            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // --- UI Interaction ---

            function createGrid() {
                gridElement.innerHTML = '';
                for (let r = 0; r < GRID_SIZE; r++) {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'row flex';
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = document.createElement('input');
                        cell.type = 'number';
                        cell.className = 'sudoku-cell flex items-center justify-center rounded-none';
                        cell.dataset.row = r;
                        cell.dataset.col = c;

                        if (board[r][c] !== EMPTY_CELL) {
                            cell.value = board[r][c];
                            cell.readOnly = true;
                            cell.classList.add('pre-filled');
                        }

                        cell.addEventListener('input', handleInput);
                        cell.addEventListener('focus', handleFocus);
                        cell.addEventListener('keydown', handleKeyDown);
                        rowDiv.appendChild(cell);
                    }
                    gridElement.appendChild(rowDiv);
                }
            }
            
            function handleInput(e) {
                if (isGameOver) {
                    e.target.value = '';
                    return;
                }
                const cell = e.target;
                const value = cell.value;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                // Clear previous incorrect styling
                cell.classList.remove('incorrect');

                // Allow only single digits from 1-9
                if (!/^[1-9]$/.test(value)) {
                    cell.value = '';
                    return;
                }
                
                // Check if the entered number is correct and apply styling
                const enteredNum = parseInt(value);
                if (enteredNum !== solution[row][col]) {
                    cell.classList.add('incorrect');
                }
            }

            function handleKeyDown(e) {
                const cell = e.target;
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                switch (e.key) {
                    case 'ArrowUp': e.preventDefault(); if (row > 0) getCell(row - 1, col).focus(); break;
                    case 'ArrowDown': e.preventDefault(); if (row < GRID_SIZE - 1) getCell(row + 1, col).focus(); break;
                    case 'ArrowLeft': e.preventDefault(); if (col > 0) getCell(row, col - 1).focus(); break;
                    case 'ArrowRight': e.preventDefault(); if (col < GRID_SIZE - 1) getCell(row, col + 1).focus(); break;
                }
            }

            function handleFocus(e) {
                highlightCells(parseInt(e.target.dataset.row), parseInt(e.target.dataset.col));
            }
            
            function highlightCells(row, col) {
                document.querySelectorAll('.sudoku-cell').forEach(c => c.classList.remove('highlight', 'selected'));
                for (let i = 0; i < GRID_SIZE; i++) {
                    getCell(row, i).classList.add('highlight');
                    getCell(i, col).classList.add('highlight');
                }
                const startRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
                const startCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
                for (let r = 0; r < BOX_SIZE; r++) {
                    for (let c = 0; c < BOX_SIZE; c++) {
                        getCell(startRow + r, startCol + c).classList.add('highlight');
                    }
                }
                getCell(row, col).classList.add('selected');
            }

            function getCell(row, col) {
                return document.querySelector(`[data-row='${row}'][data-col='${col}']`);
            }
            
            function showMessage(text, type) {
                messageBox.textContent = text;
                messageBox.className = 'mt-4 text-center text-lg font-medium p-3 rounded-lg opacity-0 transform scale-95';
                const typeClasses = {
                    success: 'bg-green-100 text-green-800',
                    error: 'bg-red-100 text-red-800',
                    info: 'bg-blue-100 text-blue-800'
                };
                messageBox.classList.add(...(typeClasses[type] || typeClasses.info).split(' '));
                
                setTimeout(() => messageBox.classList.replace('opacity-0', 'opacity-100'), 10);
                setTimeout(() => messageBox.classList.replace('opacity-100', 'opacity-0'), 3000);
            }

            function updateAttemptsUI() {
                attemptsContainer.innerHTML = `Attempts: ${'❤️'.repeat(failureAttempts)}${'🤍'.repeat(MAX_ATTEMPTS - failureAttempts)}`;
            }

            // --- Game Logic ---

            function checkSolution() {
                if (isGameOver) return;

                let isComplete = true;
                let isCorrect = true;

                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = getCell(r, c);
                        const cellValue = parseInt(cell.value) || EMPTY_CELL;

                        if (cellValue === EMPTY_CELL) isComplete = false;
                        if (cellValue !== solution[r][c]) isCorrect = false;
                    }
                }

                if (!isComplete) {
                    showMessage("The board is not completely filled yet.", "info");
                    return;
                }

                if (isCorrect) {
                    showMessage("Congratulations! You solved it correctly!", "success");
                    isGameOver = true;
                    checkBtn.disabled = true;
                } else {
                    failureAttempts--;
                    updateAttemptsUI();
                    if (failureAttempts > 0) {
                        showMessage(`Not quite right. You have ${failureAttempts} attempts left.`, "error");
                    } else {
                        showMessage("Game Over! Better luck next time.", "error");
                        gameOver();
                    }
                }
            }

            function solvePuzzle() {
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = getCell(r, c);
                        if (!cell.readOnly) {
                            cell.value = solution[r][c];
                            cell.classList.remove('incorrect');
                            cell.classList.add('text-blue-600', 'font-bold');
                        }
                    }
                }
                showMessage("Here is the solution!", "info");
                gameOver();
            }
            
            function gameOver() {
                isGameOver = true;
                document.querySelectorAll('.sudoku-cell:not(.pre-filled)').forEach(cell => cell.readOnly = true);
                checkBtn.disabled = true;
            }

            function startNewGame() {
                isGameOver = false;
                failureAttempts = MAX_ATTEMPTS;
                checkBtn.disabled = false;
                updateAttemptsUI();
                generatePuzzle();
                createGrid();
                showMessage("New game started. Good luck!", "info");
            }

            // --- Event Listeners ---
            newGameBtn.addEventListener('click', startNewGame);
            checkBtn.addEventListener('click', checkSolution);
            solveBtn.addEventListener('click', solvePuzzle);

            // --- Initial Load ---
            startNewGame();
        });
    </script>
</body>
</html>
